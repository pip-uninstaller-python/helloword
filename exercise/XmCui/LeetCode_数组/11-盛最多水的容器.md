给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)


图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/container-with-most-water
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这个题一开始我用的暴力穷举法,太慢了,直接给我报超时,用java写了一遍还是太慢.后来想了一下用双指针法来搞

这个算法的思路是,从最左边和最右边开始取值,这就保证长方形在坐标轴上的这个长度是最长的;用==短垂直线==乘以坐标轴上的长度,就是这两个点与坐标轴围成的可以盛最多水的面积

然后精妙的是,我们将更短的垂直线向中间移动,下面解释原因:

首先,无论移动哪个边,两个点接近,坐标轴上的这个边都是变短的.要想面积变大,由短垂直线构成的边必须要增大才==有可能==

如果我们移动长垂直线,如果新垂直线比原短边更长,仍使用原短边算面积,面积必定减少;如果新垂直线比元短边,使用更短的边计算面积,面积必定减少;

而如果移动短垂直线,新移动到的垂直线比原来的短垂直线更短,使用新的短边,面积必定减少;如果新垂直线比原短边长,那么无论它是不是比原来的长边长,构成面积的新短边都比原短边要长,所以面积==可能==增加

所以我们移动短边


	class Solution:
    def maxArea(self, height: List[int]) -> int:
        li,ri,s_max=0,len(height)-1,0
        while li<ri:
            s=min(height[li],height[ri])*(ri-li)
            s_max=s if s>s_max else s_max
            if height[li]>height[ri] :
                ri-=1
            else :
                li+=1
        return s_max

li是左指针指向最左端,ri是右指针指向最右端;计算面积,和最大面积比较,取大值,然后移动短边的指针
